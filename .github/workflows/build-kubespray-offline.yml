name: Build Kubespray Offline Images

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

env:
  KUBESPRAY_VERSION: "2.25.0"
  VERSION_PREFIX: "v0.1.0"
  REGISTRY: docker.io
  FILES_IMAGE_NAME: kubespray-files
  IMAGES_IMAGE_NAME: kubespray-images

jobs:
  build-files:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.FILES_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}
            type=raw,value=latest

      - name: Verify files lists exist
        run: |
          echo "Checking for architecture-specific files lists..."
          if [ ! -f "temp/files-amd64.list" ]; then
            echo "Error: temp/files-amd64.list not found"
            exit 1
          fi
          if [ ! -f "temp/files-arm64.list" ]; then
            echo "Error: temp/files-arm64.list not found"
            exit 1
          fi
          echo "✓ Both files lists found"
          echo "AMD64 files: $(wc -l < temp/files-amd64.list)"
          echo "ARM64 files: $(wc -l < temp/files-arm64.list)"

      - name: Create Dockerfile for multi-arch files
        run: |
          cat > Dockerfile.files << 'EOF'
          FROM nginx:1.25.2-alpine

          # Install wget and other tools
          RUN apk add --no-cache wget ca-certificates

          # Create directory structure
          RUN mkdir -p /opt/k8s/k8s

          # Copy both architecture files lists
          COPY temp/files-amd64.list /tmp/files-amd64.list
          COPY temp/files-arm64.list /tmp/files-arm64.list

          # Create download script with error handling and retry
          RUN cat > /tmp/download.sh << 'DOWNLOAD_EOF'
          #!/bin/sh
          set -e

          download_file() {
              local url="$1"
              local max_retries=3
              local retry=0
              
              echo "Downloading: $url"
              
              while [ $retry -lt $max_retries ]; do
                  if wget -x -P k8s --timeout=60 --tries=3 --waitretry=5 "$url"; then
                      echo "✓ Success: $url"
                      return 0
                  else
                      retry=$((retry + 1))
                      echo "⚠ Retry $retry/$max_retries: $url"
                      sleep 5
                  fi
              done
              
              echo "✗ Failed after $max_retries attempts: $url"
              return 1
          }

          cd /opt/k8s

          echo "=== Downloading AMD64 architecture files ==="
          failed_files=""
          total_files=0
          success_files=0

          while IFS= read -r url; do
              if [ -n "$url" ] && [ "${url#\#}" = "$url" ]; then
                  total_files=$((total_files + 1))
                  if download_file "$url"; then
                      success_files=$((success_files + 1))
                  else
                      failed_files="$failed_files\n$url"
                  fi
              fi
          done < /tmp/files-amd64.list

          echo "AMD64: $success_files/$total_files files downloaded"

          echo "=== Downloading ARM64 architecture files ==="
          total_files=0
          success_files=0

          while IFS= read -r url; do
              if [ -n "$url" ] && [ "${url#\#}" = "$url" ]; then
                  total_files=$((total_files + 1))
                  if download_file "$url"; then
                      success_files=$((success_files + 1))
                  else
                      failed_files="$failed_files\n$url"
                  fi
              fi
          done < /tmp/files-arm64.list

          echo "ARM64: $success_files/$total_files files downloaded"

          if [ -n "$failed_files" ]; then
              echo "=== Failed downloads ==="
              echo "$failed_files"
              echo "⚠ Some files failed to download, but continuing..."
          fi

          echo "=== Download complete ==="
          DOWNLOAD_EOF

          # Make script executable and run it
          RUN chmod +x /tmp/download.sh && \
              /tmp/download.sh && \
              rm /tmp/download.sh /tmp/files-amd64.list /tmp/files-arm64.list

          # Configure nginx with directory listing
          RUN cat > /etc/nginx/conf.d/default.conf << 'NGINX_EOF'
          server {
              listen 80 default_server;
              listen [::]:80 default_server;
              
              location /k8s/ {
                  root /opt/k8s;
                  index index.html index.htm;
                  autoindex on;
                  autoindex_exact_size off;
                  autoindex_localtime on;
              }
              
              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
              location / {
                  access_log off;
                  return 200 "Hi Kubespray Files here\n";
                  add_header Content-Type text/plain;
              }
          }
          NGINX_EOF

          EXPOSE 80

          CMD ["nginx", "-g", "daemon off;"]
          EOF

      - name: Build and push multi-arch files image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.files
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=files-multiarch
          cache-to: type=gha,mode=max,scope=files-multiarch

      - name: Verify image
        run: |
          echo "=== Verifying built image ==="
          docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.FILES_IMAGE_NAME }}:${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}
          
          echo "=== Testing image ==="
          docker run -d --name test-files -p 8080:80 \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.FILES_IMAGE_NAME }}:${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}
          
          sleep 5
          
          echo "=== Checking AMD64 files ==="
          curl -f http://localhost:8080/k8s/dl.k8s.io/release/v1.29.10/bin/linux/amd64/ || echo "AMD64 path check failed"
          
          echo "=== Checking ARM64 files ==="
          curl -f http://localhost:8080/k8s/dl.k8s.io/release/v1.29.10/bin/linux/arm64/ || echo "ARM64 path check failed"
          
          docker stop test-files
          docker rm test-files
          
          echo "✓ Image verification complete"

  build-images:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        arch: [amd64, arm64]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Install skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Pull and save images for architecture
        run: |
          mkdir -p registry-data-${{ matrix.arch }}
          
          # Start a local registry
          docker run -d -p 5000:5000 --name registry \
            -v $(pwd)/registry-data-${{ matrix.arch }}:/var/lib/registry \
            registry:3
          
          # Wait for registry to be ready
          sleep 5
          
          # Sync images with architecture filter
          while IFS= read -r image; do
            if [ -n "$image" ]; then
              echo "Syncing: $image for ${{ matrix.arch }}"
              repo_name=$(echo "$image" | sed 's|[^/]*/||')
              
              # Copy with architecture override
              skopeo copy --dest-tls-verify=false \
                --override-arch ${{ matrix.arch }} \
                --override-os linux \
                "docker://${image}" \
                "docker://localhost:5000/k8s/${repo_name}" || echo "Failed: $image"
            fi
          done < temp/images.list
          
          # Stop registry
          docker stop registry
          docker rm registry

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}-${{ matrix.arch }}
            type=raw,value=latest-${{ matrix.arch }}

      - name: Create Dockerfile for images
        run: |
          cat > Dockerfile.images << 'EOF'
          FROM registry:3

          # Copy pre-synced registry data
          ARG TARGETARCH
          COPY registry-data-${TARGETARCH} /var/lib/registry

          # Create registry config
          RUN mkdir -p /etc/docker/registry && \
              cat > /etc/docker/registry/config.yml << 'CONFIG_EOF'
          version: 0.1
          log:
            fields:
              service: registry
          storage:
            cache:
              blobdescriptor: inmemory
            filesystem:
              rootdirectory: /var/lib/registry
          http:
            addr: :5000
            headers:
              X-Content-Type-Options: [nosniff]
          health:
            storagedriver:
              enabled: true
              interval: 10s
              threshold: 3
          CONFIG_EOF

          # Create startup script
          RUN cat > /docker-entrypoint.sh << 'SCRIPT_EOF'
          #!/bin/sh
          set -e
          
          echo "=========================================="
          echo "Kubespray Offline Registry"
          echo "=========================================="
          echo "Architecture: $(uname -m)"
          echo "Registry: hub.kubespray.local:5000"
          echo ""
          echo "Usage:"
          echo "  List images: curl http://hub.kubespray.local:5000/v2/_catalog"
          echo "  Pull image:  docker pull hub.kubespray.local:5000/k8s/pause:3.9"
          echo "=========================================="
          
          exec /entrypoint.sh "$@"
          SCRIPT_EOF
          
          RUN chmod +x /docker-entrypoint.sh

          EXPOSE 5000

          ENTRYPOINT ["/docker-entrypoint.sh"]
          CMD ["/etc/docker/registry/config.yml"]
          EOF

      - name: Build and push images image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.images
          platforms: linux/${{ matrix.arch }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            TARGETARCH=${{ matrix.arch }}
          cache-from: type=gha,scope=images-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=images-${{ matrix.arch }}

  create-images-manifest:
    needs: build-images
    runs-on: ubuntu-latest
    steps:
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        run: |
          # Create manifest for versioned tag
          docker buildx imagetools create -t \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }} \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}-amd64 \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:${{ env.VERSION_PREFIX }}-${{ env.KUBESPRAY_VERSION }}-arm64
          
          # Create manifest for latest tag
          docker buildx imagetools create -t \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:latest \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:latest-amd64 \
            ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGES_IMAGE_NAME }}:latest-arm64
